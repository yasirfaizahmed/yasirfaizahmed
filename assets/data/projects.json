[
  {
    "id": "twitter-automation",
    "title": "Twitter Automation",
    "summary": "Automation Framework for twitter.",
    "tags": [
      "Automation",
      "Web scraping"
    ],
    "link": "#",
    "image": "assets/images/articles/11-twitter-automation-tools-for-your-brand-in-2024-final.jpg",
    "imageAlt": "",
    "details": "## 1) About\nThis is a **Python-based Twitter/X web automation framework** that automates actions without using the official Twitter API. Instead, it relies on browser/UI automation layers:\n- **Selenium** (primary web interaction)\n- **PyAutoGUI + OpenCV template matching** (fallback/visual clicks for UI elements)\n- **OpenAI API integration** (legacy GPT text generation for tweets)\n\nThe README positions it as an alternative to expensive official API usage.\n\n---\n\n## 2) Core capabilities implemented\nFrom the code, the main implemented workflows are:\n- **Login** to Twitter/X (supports alternate login flows: email/username/phone + password)\n- **Tweet posting** (`Tweet` class)\n  - text-only tweets\n  - optional media upload via Selenium file input\n  - optional PyAutoGUI-based UI clicking mode\n- **Like single post** (`Like`)\n- **Retweet single post** (`Retweet`)\n- **Like multiple posts from a profile** (`LikePosts`)\n- **Retweet multiple posts from a profile** (`RetweetPosts`)\n- **Collect tweet text data from a profile** into CSV/TXT (`CollectUserTweetData`)\n- **Profile reporting workflow** (WIP-ish, but present) driven by icon templates\n- **OpenAI-generated tweet posting** (`OpenaiTweet`, legacy Completion API)\n\nThere are also specialized automations under `automation/` (e.g., hadith image post script, Ramadan progress scripts).\n\n---\n\n## 3) Repo structure and architecture\nIt uses a lightweight framework style with reusable patterns:\n\n### Key folders\n- `APIs/Selenium/` → most Twitter actions and browser driver setup\n- `APIs/CV/` and `APIs/PyAutoGUI/` → image-based GUI interaction steps\n- `APIs/GPT/` → OpenAI response wrapper\n- `base/` → framework base classes (`BaseStep`, `BaseScript`)\n- `data_handler/` → metadata loading + data file creation\n- `log_handling/` → singleton logger\n- `patterns/` → singleton metaclass + timeout decorator\n- `examples/` → runnable usage samples\n- `config/` → selectors/XPaths and legacy configs\n- `template_images/` → CV templates used in PyAutoGUI/OpenCV workflows\n\n### Design pattern used\n- **Step-based execution model**:\n  - `BaseStep` defines lifecycle: `Do()` then `CheckCondition()` returning structured response (`ok`, `data`)\n- **Singleton-heavy state management**:\n  - Selenium client, metadata handler, and logger are mostly singleton-backed\n- This gives reusable shared session behavior but may reduce test isolation.\n\n---\n\n## 4) Important implementation details\n\n### Selenium driver setup\n`APIs/Selenium/selenium_step.py`:\n- Uses `webdriver.Chrome` with `Service(executable_path=DRIVER_PATH)`\n- Reads `DRIVER_PATH` env var, fallback to local `chrome-driver/chromedriver`\n- Chrome options include `--no-sandbox`, `--disable-dev-shm-usage`, etc.\n\n### Credentials/metadata\n`data_handler/data_handler.py`:\n- Loads bot creds from JSON via `METADATA` env var\n- Default fallback is `bot_metadata.json` in repo root\n- Exposes bot records via `BotMetadata().data`\n\nExpected metadata shape (README):\n```json\n{\n  \"bot1\": {\n    \"EMAIL_KEY\": \"...\",\n    \"USERNAME_KEY\": \"...\",\n    \"PASSWORD_KEY\": \"...\"\n  }\n}\n```\n(Actual login flow also may use `PHONE_NUMBER` if username prompt fails.)\n\n### Logging\n`log_handling/log_handling.py`:\n- Creates both stdout and file logs\n- Log files stored in auto-created `_LOGs/` folder\n\n### Tweet data export\n`CollectUserTweetData`:\n- Scrolls profile timeline, captures visible tweet text blocks\n- Writes to CSV/TXT in `_USER_DATA/`\n- Uses timeout decorator (`patterns.timeout`) to cap run duration\n\n---\n\n## 5) Example usage in repo\nIn `examples/`:\n- `tweet.py` → login + tweet + optional media\n- `like.py` → like a specific tweet URL\n- `retweet.py` → retweet a specific tweet URL\n- `openai_tweet.py` → generate tweet text from prompt/tags, optionally as image\n\nSo the practical entrypoint is currently **example scripts**, not a production CLI (the Typer CLI in `interface/main.py` is only demo commands `hello/goodbye`).\n\n---\n\n## 6) Dependencies and tooling\nFrom `requirements.txt`:\n- `selenium`, `opencv-python`, `PyAutoGUI`, `pillow`\n- `openai` (legacy usage in code)\n- `pandas`, `nltk`, `Quote2Image`\n- lint/tooling: `pre-commit`, `ruff`, `flake8` workflow\n\nAlso includes:\n- `Dockerfile` (Python 3.12 slim + requirements + ssh server setup)\n- `.github/workflows/flake8.yml`\n- `.pre-commit-config.yaml`\n\n---\n\n## 7) Strengths of this project\n- Clear separation of action “steps” and reusable automation components\n- Supports both DOM-level (Selenium) and visual-level (OpenCV/PyAutoGUI) automation\n- Includes data collection and media workflows, not just simple likes/retweets\n- Practical examples make onboarding easier\n\n---\n\n## 8) Limitations / fragility points\n- Heavy use of **absolute XPaths** in configs → brittle when Twitter UI changes\n- Some classes marked WIP and some naming/style inconsistencies\n- Legacy OpenAI Completion model usage (`text-davinci-003`) is outdated\n- Error handling often logs + continues, limited retry/backoff strategy\n- Singleton usage can complicate parallel runs and testing\n\n---\n\n## 9) Setup summary (as intended by repo)\nAt high level:\n1. Clone repo\n2. Install Python deps (`pip install -r requirements.txt`)\n3. Install system packages (`package.txt` mentioned in README; ensure chrome/chromedriver compatibility)\n4. Set env vars:\n   - `DRIVER_PATH`\n   - `METADATA`\n   - optional `API_KEY` (OpenAI)\n5. Run examples, e.g.:\n   - `python examples/like.py`\n   - `python examples/tweet.py`\n\n---\n\n## 10) Quick architectural mental model\nThink of it as:\n- **Engine layer**: Selenium client + GUI automation helpers\n- **Step layer**: granular actions (`OpenPage`, `FindBy`, `Click`, `Write`, etc.)\n- **Workflow layer**: end-user operations (`Login`, `Tweet`, `LikePosts`, etc.)\n- **Support layer**: metadata, logs, paths, decorators\n\nThat makes extension straightforward: add a new Step/Workflow class and wire selectors/config.\n\n---"
  },
  {
    "id": "low-level-drivers-for-stm32f405-for-nrf24l01-transceiver",
    "title": "Low level drivers for stm32f405 for nRF24L01 transceiver",
    "summary": "Custom nRF24L01 transceiver module driver for a stm32f103 target device",
    "tags": [
      "Electronics",
      "Embedded systems"
    ],
    "link": "#",
    "image": "assets/images/articles/chatgpt-image-feb-14-2026-120718-am.png",
    "imageAlt": "stm32f405 meets nrf24l01",
    "details": "﻿# FINALYEAR_PROJECT\n## Custom nRF24L01 transceiver module driver for a stm32f103 target device\n\n### INTRODUCTION\n\nThis project is all about creating a custom library from scratch for a nRF24L01 transceiver module, the code developed here will run on a stm32f103C8 microcontroller (also known as the BLUEPILL) which is a very handy and pretty cheap uC.\nThis nRF module is designed and manufactured by NordicSemiconductors™ and as a matter of fact its pretty well designed and has a lot of features required to compete the ever growing tech world.\n\n### RESEARCH / REFERENCES\n\nAs I have mentioned above, its totally from scratch and this is by referring the two holy grails of reference manuals of nRF and as well as stm32f103C8 uC.\n\nyou can download the manuals from here.\n\n[stm32f103C8](https://www.st.com/resource/en/reference_manual/cd00171190-stm32f101xx-stm32f102xx-stm32f103xx-stm32f105xx-and-stm32f107xx-advanced-arm-based-32-bit-mcus-stmicroelectronics.pdf)\n\n[nRF24L01](https://www.mouser.com/datasheet/2/297/nRF24L01_Product_Specification_v2_0-9199.pdf) \n\n\n### Key features of the end product code\n\t• Max data rate exchange rates upto 8Mbps\n\t• Half-duplex communication behaviour\n\t• CRC enabled data transmissions and receptions with auto acknoledgements\n\t• can talk upto 6 diffrent other nRF modules (still in progress)\n\t• and much more..\n\n\n\n### Key Features of the modules \n\n### nRF24L01 transceiver module\n\n![alt text](https://github.com/yasirfaizahmed/FINALYEAR_PROJECT/blob/master/images/download.jpg)\n\n\t• Worldwide 2.4GHz ISM band operation\n  \t• Up to 2Mbps on air data rate\n  \t• Ultra low power operation\n  \t• 11.3mA TX at 0dBm output power\n  \t• 12.3mA RX at 2Mbps air data rate\n  \t• 900nA in power down\n  \t• 22μA in standby-I\n  \t• On chip voltage regulator\n  \t• 1.9 to 3.6V supply range\n  \t• Enhanced ShockBurst™\n  \t• Automatic packet handling\n  \t• Auto packet transaction handling\n  \t• 6 data pipe MultiCeiver™\n  \t• Air compatible with nRF2401A, 02, E1 and E2\n  \t• Low cost BOM\n  \t• ±60ppm 16MHz crystal\n  \t• 5V tolerant inputs\n  \t• Compact 20-pin 4x4mm QFN package\n\n### stm32f103C8 uC\n\n![alt text](https://github.com/yasirfaizahmed/FINALYEAR_PROJECT/blob/master/images/stm.jpg)\n\n\t**ARM®32-bit Cortex®-M3 CPU Core**\n\n\t• 72 MHz maximum frequency,1.25 DMIPS/MHz (Dhrystone 2.1) performance at 0 wait state memory access\n\t• Single-cycle multiplication and hardware division\n\t\n\t**Memories**\n\n\t• 64 or 128 Kbytes of Flash memory\n\t• 20 Kbytes of SRAM\n\n\t**Clock, reset and supply management**\n\n\t• 2.0 to 3.6 V application supply and I/Os\n\t• POR, PDR, and programmable voltage detector (PVD)\n\t• 4-to-16 MHz crystal oscillator\n\t• Internal 8 MHz factory-trimmed RC\n\t• Internal 40 kHz RC\n\t• PLL for CPU clock\n\t• 32 kHz oscillator for RTC with calibration\n\n\t**Low-power**\n\n\t• Sleep, Stop and Standby modes\n\t• VBAT supply for RTC and backup registers\n\n\t**2 x 12-bit, 1 μs A/D converters (up to 16 channels)**\n\n\t• Conversion range: 0 to 3.6 V\n\t• Dual-sample and hold capability\n\t• Temperature sensor\n\n\t**DMA**\n\n\t• 7-channel DMA controller\n\t• Peripherals supported: timers, ADC, SPIs, I2Cs and USARTs\n\t• Up to 80 fast I/O ports\n\t• 26/37/51/80 I/Os, all mappable on 16 external interrupt vectors and almost all 5 V-tolerant\n\n\t**Debug mode**\n\n\t• Serial wire debug (SWD) & JTAG interfaces\n\n\t**7 timers**\n\n\t• Three 16-bit timers, each with up to 4 IC/OC/PWM or pulse counter and quadrature (incremental) encoder input\n\t• 16-bit, motor control PWM timer with dead-time generation and emergency stop\n\t• 2 watchdog timers (Independent and Window)\n\t• SysTick timer 24-bit downcounter\n\n\t**Up to 9 communication interfaces**\n\n\t• Up to 2 x I2C interfaces (SMBus/PMBus)\n\t• Up to 3 USARTs (ISO 7816 interface, LIN, IrDA capability, modem control)\n\t• Up to 2 SPIs (18 Mbit/s)\n\t• CAN interface (2.0B Active)\n\t• USB 2.0 full-speed interface\n\n\t**CRC calculation unit, 96-bit unique ID**\n\n\t• Packages are ECOPACK®\n  \n-------------------------------------------------------------------------------\n-------------------------------------------------------------------------------\n-------------------------------------------------------------------------------\n### REGISTERS DEFINITTIONS \n\n### CONFIG REG\n![](https://github.com/yasirfaizahmed/FINALYEAR_PROJECT/blob/master/images/config_reg.jpg)\n\n0 : PRIM_RX : Controls the NRF mode [ 1= Receiver ] [ 0 = Transmitter ]\n\n1 : PWR_UP  : Power up control. [1 = Power up]  [0 = Power down]\n\n2 : CRCO : Set CRC encoding scheme. [1 = 2 Bytes]  [0 = 1 Byte].\n\n3 : EN_CRC   : Enables the CRC (more on this later) If any channel has Auto Ack enabled the CRC is\nalso forced to be enabled. \n\n4 : MASK_MAX_RT : Enables/Disables whether the MAX_RT interrupt drives the IRQ pin\n\n5 : MASK_TX_DS     : Enables/Disables whether the TX_DS interrupt drives the IRQ pin\n\n6 : MASK_RX_DR    :  Enables/Disables whether the RX_DR interrupt drives the IRQ pin\n\nBits 0 and 1 are pretty self explanatory. Bit 2 controls how many bytes are used for the CRC scheme, basically the NRF will add either 1 or 2 bytes at the end of a transmission when CRC is enabled. And as noted when any channel has auto acknowledge enabled the CRC is forced. \n\nCRC and auto Ack work in conjunction to make sure data reception is only presented when the data is valid. The NRF will run a CRC algorithm on the address, packet control (if there is one) and your payload. The result of that is a \"CRC code\"  and it will add that code to the frame format and transmit it along with your data. Then the transmitter will turn itself into a receiver, no code required to do this, and listen for an ACK to verify the data was received.\n\nThe receiver will receive the entire frame packet and extract your data and run the same CRC algorithm on it. If the CRC code that results from the receivers CRC engine is the same as the one sent by the transmitter then it means they both ran the same CRC algorithm on the exact same data and thus no bits were lost or modified or noise etc.. therefore the data is valid. \n\nAt this point the receiver will momentarily turn into a transmitter, all on its own no code required, and it will send an ACK command to the transmitter telling it that it received the data. If the CRC codes do not match then the receiver does not send anything and discards the data.\nNote that both receiver and transmitter need to have auto ACK enabled for this scheme to work, this is what they call \"Enhanced Shockburst\".\n\nshockburts format \n![](https://github.com/yasirfaizahmed/FINALYEAR_PROJECT/blob/master/images/shockburst%20(1).jpg)\n\nthe Preamble is nothing more then a sequence of 1s and 0s to synchronize the receiver's demodulator to the incoming stream. It is only one byte long, if the first bit in the address is a 1 then the preamble is 10101010, otherwise it is 01010101.\n\n\n### EN_AA REG\n![](https://github.com/yasirfaizahmed/FINALYEAR_PROJECT/blob/master/images/EN_AA%20REG.jpg)\n0 - 5 : This bits are used to enable auto acknowledge on the given pipe number. \n\nA \"Pipe\" is basically like a different channel but not a frequency channel, think of it as the name suggest a Pipe. Imagine one big Pipe where all the data comes through, this would be your frequency 2.4 Ghz give or take some megahertz because you have the option to change the frequency channels. Your data travels on this frequency and that is the BIG pipe so to speak. When it gets to the receiver it now can go down several other small pipes each with its own address. That is why when you transmit a data packet you send an address\n\n### EN_RX_ADDR REG\n![](https://github.com/yasirfaizahmed/FINALYEAR_PROJECT/blob/master/images/EN_RX_ADDR%20REG.jpg)\n0 - 5 : This bits are used to enable a given pipe number.\n\nThis is the register where you enable all pipes that you will be using. Setting a 1 in its corresponding bit enables it you can have more than one or all enabled at the same time.\n\n### SETUP_AW REG\n![](https://github.com/yasirfaizahmed/FINALYEAR_PROJECT/blob/master/images/SETUP_AW%20REG.jpg)\nThis register only uses 2bits to set the width of the pipe addresses.  The values allowed are as follow:\n\n\t00 - Illegal\n\t01 - 3 bytes\n\t10 - 4 bytes\n\t11 - 5 bytes\n\nRemember that the address is transmitted every time you send a packet so having less bytes to transmit can be beneficial in some applications but the robustness of having more bytes may be useful in other applications.\n\n### SETUP_RETR REG\n![](https://github.com/yasirfaizahmed/FINALYEAR_PROJECT/blob/master/images/SETUP_RETR%20REG.jpg)\n0-3 : ARC : These bits are used to set how many times the transmitter will re-transmit when it fails to                         receive an auto ACK from the receiver.  \n\nAcceptable values are:\n\n\t0000 - re-transmit disabled\n\t0001 - 1 re-transmit\n\t0010 - 2 re-transmit\n\t........ etc .......\n\t1111 - 15 re-transmit\n\n\n4-7 : ARD :  These bits are used to assign a designated waiting period before each re-transmission.\n\nAcceptable values are:\n\n\t0000 - Wait 250 uS\n\t0001 - Wait 500 uS\n\t0010 - Wait 750 uS\n\t........ etc .......\n\t1111 - Wait 4000 uS\n\n### RF_CH REG\n![](https://github.com/yasirfaizahmed/FINALYEAR_PROJECT/blob/master/images/RF_CH%20REG.jpg)\nThis register uses bits 0 through 6 to set the channel frequency where your NRF will transmit and receive its data. Needless to say that both transmitter and receiver need to be on the same frequency. Also needless to say you get 126 RF channels to chose from. 000000 is not acceptable, hence why you dont have 127\n\n\n\n### RF_SETUP REG\n![](https://github.com/yasirfaizahmed/FINALYEAR_PROJECT/blob/master/images/RF_SETUP%20REG.jpg)\n0    : Obsolete / Not used \n\n1-2 : RF_PWR : Set the output power in TX mode \n\nAcceptable values are: \n    00 : -18dBm\n    01 : -12dBm\n    10 : -6dBm\n    11 : 0dBm\n\n3 : RF_DR_HIGH : Select one of the high data rates : [ 0 = 1Mbps ] [ 1 = 2Mbps ]\n\n4 : PLL_LOCK : This bit is used for testing . Not relevant for operation. Leave at reset value of 0\n\n5 : RF_DR_LOW : Set the data rate to its lowest of 250kbs, if this is set it overrides RF_DR_HIGH\n\n6 : RESERVED\n\n7 : CONT_WAVE :  This bit enables continuous transmission. \n\nThe RF_PWR and PLL_LOCK bits should for the most part be left alone. The PLL_LOCK bit is used for a testing procedure explained in the datasheet, you ca view that on your ow. The RF_PWR bit controls the output power, if you do not know anything about analog electronics, 0dBm does not mean zero output power. Unless you have power consumption restrictions to meet you should not really set it below 0dBm.\n\n\n### STATUS REG\n![](https://github.com/yasirfaizahmed/FINALYEAR_PROJECT/blob/master/images/STATUS%20REG.jpg)\n0 : TX_FULL : When this bit is set it means the TX FIFO is full and you must either read some data or  risk it being lost as it pushes out the oldest data to fill it with new incoming data\n\n1-3: RX_P_NO : Tells you on what Pipe there is the current data available to read.\n\n4 : MAX_RT : This is an interrupt that signals when the maximum number of re-transmits has been    reached. Write a 1 to clear this bit\n\n5 : TX_DS : Interrupt that signals when the data packet has been transmitted. If auto ACK is                  enabled his interrupt will only trigger when the ACK is received. Write 1 to clear\n\n6 : RX_DR : This interrupt signals that new data has arrived to be read from the FIFO. Write 1 to            clear it.\n\nLike stated in the CONFIG register description, these interrupts can drive the IRQ pin low when the flags are set. And like most status registers the interrupts are cleared by writing a 1 to the bit. \n\n### OBSERVE_TX REG\n![](https://github.com/yasirfaizahmed/FINALYEAR_PROJECT/blob/master/images/OBSERVE_TX%20REG.jpg)\n0-3 : ARC_CNT : These bits tell current count of re-transmit\n\n4-7 : PLOS_CNT : These bits keep track of how many packets have been lost after the max re-transmit\n\nWhen ARC_CNT exceeds the max number of re-transmits set in the SETUP_RETR register it triggers the MAX_RT interrupt , which in turn may or may not trigger the IRQ pin to go low depending on your settings\n\n### RPD REG\t\n![](https://github.com/yasirfaizahmed/FINALYEAR_PROJECT/blob/master/images/RPD%20REG.jpg)\nThe RPD register has only one readable bit that signals power levels above -64dBm present in the RF channel you are using. Otherwise it reads 0.\n\n\n### RX_ADDR_P0\n![](https://github.com/yasirfaizahmed/FINALYEAR_PROJECT/blob/master/images/RX_ADDR.jpg)\nif you look carefully, the image above depicts two registers, RX_ADDR_P0 and register RX_ADDR_P1.  This does not mean there are two registers in one, I am simply stating that both RX_ADDR_P0 and RX_ADDR_P1 have up to 5bytes (40 bits)  All these bits are used to set a unique address of your choice to Pipe 0 and Pipe 1. You do not have to use all 5 bytes but if you want to use 5 bytes these are the only two Pipes that support 5 byte of unique address space.\n\n### RX_ADDR_P1-P5\n![](https://github.com/yasirfaizahmed/FINALYEAR_PROJECT/blob/master/images/RX_ADDR%20P2-P5.jpg)\nThe rest of the Pipe's addresses only support a one byte address. The diagram above is also pretty self explanatory. \nWell technically speaking all the pipes addresses are 5 bytes but for these piepes you can only change the low byte, all the other 4 high bytes are equal to the high 4 bytes that are set in pipe 1 \n\n\n### TX_ADDR  REG\n![](https://github.com/yasirfaizahmed/FINALYEAR_PROJECT/blob/master/images/TX_ADDR%20REG.jpg)\nThis register is also 5bytes (40bits) long,  In this register you enter the address that has to match the pipe address on the receiver that listening. It does not have to be 5bytes long, since some pipes only support at one byte addresses.\n\n### RX_PW_p1-P5 REG\n![](https://github.com/yasirfaizahmed/FINALYEAR_PROJECT/blob/master/images/RX_PW%20REG.jpg)\nThese 6 registers RX_PW_P0 ... through... RX_PW_P5  hold the number of bytes that are available to read on the specific pipe.\n\n### FIFO_STATUS REG\t\n![](https://github.com/yasirfaizahmed/FINALYEAR_PROJECT/blob/master/images/FIFO_STATUS%20REG.jpg)\n0 : RX_EMPTY : indicates there is no data in the RX FIFO\n\n1 : RX_FULL : Indicates the RX FIFO is full...go figure \n\n4 : TX_EMPTY : Indicates TX FIFO is empty\n\n5 : TX_FULL : take a wild guess......\n\n6 : TX_REUSE : reuses / resend the previously sent TX payload (data packet)\n\n\n### DYNPD REG\n![](https://github.com/yasirfaizahmed/FINALYEAR_PROJECT/blob/master/images/DYNPD%20REG.jpg)\nWhen you transmit data as a transmitter to a receiver, both must agree on the payload length otherwise the receiver will not acknowledge the received payload. \n\nHowever this register allows you to send data of variable length without the need to have a predefined data width. each bit in this register enabled Dynamic Payload on a given pipe. However the Dynamic payload feature also must be enabled , in order for an individual pipe to also have dynamic payload. The feature is enabled in the next register. \n\n### FEAUTURE REG\n![](https://github.com/yasirfaizahmed/FINALYEAR_PROJECT/blob/master/images/Feature%20REG.jpg)\n0 : EN_DYN_ACK : Enables the NOACK feature\n\n1 : EN_ACK_PAY : Allows the receiver to also send a payload along with an AUTO ACK\n\n2 : EN_DPL : Enables dynamic payload\n\nThe EN_DYN_ACK bit means that the receiver does not have to send an ACK and the transmitter is also not expecting one. \nThe auto ack sent by a receiver to tell the transmitter is usually does not include any payload , but you can do that if you would like by enabling the EN_ACK_PAY  bit. And ultimately EN_DPL is self explanatory.\n\n-------------------------------------------------------------------------------\n-------------------------------------------------------------------------------\n-------------------------------------------------------------------------------\n## nRF COMMANDS\nThere are only 11 commands\n\nDPI nature - nature of the SPI protocol, that with every byte you send a byte is sent back. That first byte you get back is not the reply to the command request, but just a dummy byte that needs to be sent.\n\n\n------------------------------ command 1 ---------------------------------\n### command: R_REGISTER\n### code   : 000xxxxx\n\nThe R_REGISTER command is used to Read a register and its opcode is 000xxxxx where the x's represent the address of the register you wish to read. For example if you want to read the contents of the RF_SETUP register which is address 0x06 ( 00000110 ) you would simply join the R_REGISTER command with the RF_SETUP address , which if you look at it ends up being just the RF_SETUP command anywyas.. then you send that through SPI and transmit. Then youll get a dummy byte, you can ignore it, to get your actual reply you need to send a dummy byte also because thats how SPI works and you will get the contents of the RF_SETUP register .\n\n//pseudo code\n#define R_REGISTER  0x00\n#define RF_SETUP    0x06\nspi_send ( R_REGISTER | RF_SETUP) ; \n//the returned byte will be first a dummy byte and then the contents\n\n------------------------------ command 2 ---------------------------------\n### command: W_REGISTER\n### code   : 001xxxxx\n\nThis is the Write command and you use it to write to a register. Unlike the previous command this is not just leading zeros. The x's represent the address of the register you want to write to. After sending this command the NRF expects the data that is to be written to . The SPI send would look exactly like the previous one except you OR it with W_REGISTER.\n\n//pseudo code\n#define W_REGISTER  0x20  // 00100000\n#define RF_SETUP    0x06\nspi_send ( W_REGISTER | RF_SETUP) ;\nspi_send(data)\n\n\n------------------------------ command 3 ---------------------------------\n#### command: R_RX_PAYLOAD\n### code   : 01100001\n \nThe R_RX_PAYLOAD is the command you send when you know you have received data, you will know this because the RX_DR interrupt will have been triggered.  Before you read the payload it makes sense to read STATUS register and check the  RX_P_NO bits to figure out which Pipe this data was received on.\nOr if you're only using one pipe it does not matter.\nAfter sending the R_RX_PAYLOAD command the NRF needs to transmit that data to you via SPI and in order to do that you have to send it some dummy bytes, it does not matter what the bytes are it can be 0xF1 or 0xFF... makes no difference,what does make a difference is that you need to send it the number of bytes equal to the data-width that was set in the RX_PW_P# register or alternatively there is a command to check the width of the top most payload.\n Width can be from 1 to 32 bytes\n\n\n\n------------------------------ command 4 ---------------------------------\n### command: W_TX_PAYLOAD\n### code   : 01000000\n\nThis is the command to write your payload. You must make sure that before you start the RF transmission  the CE pin must be LOW. Once you send this command the NRF expects your payload data to come next. Your data width can be from 1 to 32 bytes longs.  After the last byte is sent and you stop the SPI communication you have to bring the CE pin HIGH, because a LOW to HIGH transition is what tells the NRF to transmit what is in the TX FIFO. and this command is what writes in the TX FIFO.\n\n\n------------------------------ command 5,6 ---------------------------------\n### command: FLUSH_TX, FLUSH_RX\n### code   : 11100001, 11100010\n\n\nThese two commands clear the FIFOs, really not much else to be said here aside from the fact that the datasheet says you should not clear the RX FIFO during a transmission of ACK.  Just wait till all transmissions are done before clearing the RX FIFO.\n\n\n------------------------------ command 7 ---------------------------------\n### command: REUSE_TX_PL\n### code   : 11100011\n\nThis command allows you to resend the last transmission. You do not need to send W_TX_PAYLOAD.\nSimply send this command and it will resend the last packet so long as you have not flushed the FIFO with the commands above this one.\n\n\n\n------------------------------ command 8,9 ---------------------------------\n### command: ACTIVATE, ACTIVATE_BYTE\n### code   : 01010000, 01110011\n\nThis command activates three features at once, not necessarily enables them, but allows them to be used if desired. So its very important. The features it activates are:\n1. R_RX_PL_WID read RX payload width when using dynamic payload\n2. W_ACK_PAYLOAD allows a payload to be sent with an ack\n3. W_TX_PAYLOAD_NOACK disables ack on this specific packet\n\nthese three features are described below also. But those commands are useless unless they are activated by this command. \nThe command works by first sending the ACTIVATE command, then sending the ACTIVATE_BYTE \nso basically sending 2 SPI send actions, first the ACTIVATE then the ACTIVATE byte.\n\n\n------------------------------ command 10 ---------------------------------\n### command: R_RX_PL_WID\n### code   : 01100000\n\nThis command  reads the data width of the top payload in the RX FIFO\n\n------------------------------ command 11 ---------------------------------\n### command: W_ACK_PAYLOAD\n### code   : 10101xxx\n\nThis command is used to write the payload that will go along with an ACK, when ACK Payloads are enabled in the feature register. After this command the NRF expects the payload data which can be from 1 to 32 bytes.\n\n------------------------------ command 11 ---------------------------------\ncommand: W_TX_PAYLOAD_NO_ACK\ncode   : 10101xxx\n\nThis W_TX_PAYLOAD_NO_ACK command is used to disable auto ACK for the current packet. So you enabled this bit right before sending the W_TX_PAYLOAD command.\n\n------------------------------ command 12 ---------------------------------\n### command: NOP\n### code   : 11111111\n\nThis is a No Operation command, when you send it the NRF does nothing with it. But since you are sending a byte the SPI has to send one back so the NRF send you the contents of its STATUS register. \n\n\n\n-------------------------------------------------------------------------------\n-------------------------------------------------------------------------------\n-------------------------------------------------------------------------------\n\n### Packet Format\n\tThis is Enhanced Shockburst(TM) pakcet format from nordic \n ![](https://github.com/yasirfaizahmed/FINALYEAR_PROJECT/blob/master/images/shockburst%20(1).jpg)\n\nThe packet format consists of several fields. Also note that the entire packet of data is transmitted MSB , most significant byte first, and each byte is transmitted LSB least significant bit first. This might sound weird or confusing but do not worry the hardware inside the NRF takes care of all of that behind the scenes for you. \n\n### Preamble \nPreamble is nothing more then a sequence of 1s and 0s to synchronize the receiver's demodulator to the incoming stream. It is only one byte long, if the first bit in the address is a 1 then the preamble is 10101010, otherwise it is 01010101.\n\n### Packet Control \nThe packet control section has 3 sections within itself.\n\n1. Payload length is a 6 bit field that tells the receiver the length of the incoming payload This field however is only used when dynamic payload length is enabled. Otherwise the value in RX_PW_P# register is the width of the payload.\n\n2. PID is the packet identification field. It is used to tell the receiver \nwhether this packet is new or a re-transmitted packet. That way the receiver knows not to present a re-transmitted packet to the mcu if it has already presented this same packet before. THAT DOES NOT MEAN YOU CANNOT SEND THE SAME DATA TWICE, this \"re-transmit\" is more like an error or somehow the ACK was not received by the transmitter and now its re-transmitting the same packet. \n\n3. NO_ACK this is a bit that tells the receiver that no auto ACK should be used for this packet.\n\n\n\n\nNOTE: Every time you start an SPI communication instance you must drive low the CSN pin, this is the slave select line and makes the NRF start listening in its SPI lines.\n\n\n\n-------------------------------------------------------------------------------\n-------------------------------------------------------------------------------\n-------------------------------------------------------------------------------\n**Every time you start an SPI communication instance you must drive low the CSN pin, this is the slave select line and makes the NRF start listening in its SPI lines. I will remind you of this in the code**\n\n## Transmitting\n### Setup:\n\n1. The CE pin must start out LOW, because a HIGH to LOW transition is what causes the transmission to start. So before anything is done make sure the CE pin is LOW alos the CE pin should not be held high for too long. but the NRF takes care of that in Enhanced Shockburst mode.\n2. Next you want to power up the chip internally by setting the PWR_UP bit in the CONFIG register\n3. Clear (0) the PRIM_RX bit in the CONFIG register to use the NRF as a transmitter\n4. Set CRC encoding scheme 1 byte or 2 bytes , by setting or clearing the CRCO bit in the CONFIG register\n5. Enable the CRC itself by setting the EN_CRC bit in the CONFIG register, you can skip this since enabling auto ACK on any pipe will force this bit high anyways.\n6. Set the interrupts desired in the CONFIG register, clearing them (0) means they will be active.\n7. Set address width in the SETUP_AW \n8. Setup wait time in between re-transmissions after a failed transmission \n9. Setup max number of re-transmits\n10. As a safety measure clear interrupt flags in the STATUS register.\n\n### Sending Data\n\n1. Make sure CE is LOW\n2. Write the receivers pipe address in the TX_ADDR register (receivers pipe address and address width must match transmitter settings above)\n3. Copy the same address from TX_ADDR to Pipe 0 on  RX_ADDR_P0 register  because after transmit the NRF momentarily becomes a receiver to listen for the auto ACK and it listens on Pipe 0. Remember the address you are transmitting is at least 3 bytes long depending on the width setting. You must write that same amount of bytes in the TX_ADDR register and Pipe 0 address register \n4. Send the TX_PAYLOAD command\n5. Send the payload data.\n6. Drive the CE pin HIGH for a minimum of 10us to start the transmission and then bring it back LOW\n7. Next just handle the TX_DS interrupt or MAX_RT interrupts as you wish. Hopefully you dont get the MAX_RT interrupt because that means the data did not send, meaning there was no auto ACK received. Also if you send payloads too fast you will get a few MAX_RT interrupts because the module is not that fast and it takes time to transmit as well as get a reply."
  }
]
